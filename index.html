<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Alexius&#39;s Utopia</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="爱瞎折腾。">
<meta property="og:type" content="website">
<meta property="og:title" content="Alexius&#39;s Utopia">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Alexius&#39;s Utopia">
<meta property="og:description" content="爱瞎折腾。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alexius&#39;s Utopia">
<meta name="twitter:description" content="爱瞎折腾。">
  
    <link rel="alternate" href="/atom.xml" title="Alexius&#39;s Utopia" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Alexius&#39;s Utopia</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Amusing ourselves to death.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-在Swift中实现MVVM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/在Swift中实现MVVM/" class="article-date">
  <time datetime="2020-06-12T16:50:29.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/在Swift中实现MVVM/">【翻译】在Swift中实现MVVM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文链接：<a href="https://www.iosapptemplates.com/blog/ios-development/mvvm-swift" target="_blank" rel="noopener">How to Implement the MVVM Design Pattern in Swift</a></p>
<p>如你所知，在 Swift 中有许多适用的设计模式比如 MVC，MVP 和 MVVM。我们根据项目的需求来选择最合适的。在iosapptemplates.com，我们使用了多种模式来构建我们的函数式App。在这片文章中，我们将指出使用MVVM所带来的一些优势并且用一些Swift代码片段进行清晰地解释。</p>
<p>MVVM代表Model - View（View 在此处表示ViewController）- ViewModel（VM）。那这是什么意思呢？这意味着我们将要引入一个新的叫做View Model的组件来帮助处理繁重的工作。</p>
<p>先前，所有事情包括网络，获取响应，处理来自UI的信号等等都是在View Controller中进行。这使得View Controller臃肿过载。所以在MVVM中，我们将把上述工作和代理职责划分到view model中去。</p>
<h3 id="组件概览和具体职责"><a href="#组件概览和具体职责" class="headerlink" title="组件概览和具体职责"></a>组件概览和具体职责</h3><p>所以总的来说，我们有：</p>
<ul>
<li>View Controller：只展示和UI相关的事情——显示或者获取信息，View层的一部分</li>
<li>View Model：接收来自VC的信息，处理所有接收到的信息并返回给VC</li>
<li>Model：这只是model，同MVC中的model完全一样。VM使用它，并在VM发送新更新时进行更新</li>
</ul>
<p><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.25.44-PM.png" alt></p>
<p>在一个实际的项目中，应该记住两个主要的点：</p>
<ol>
<li>像这样分离工作所带来的便利。</li>
<li>负责任何特定部分的每个组件都将彼此完全独立。</li>
</ol>
<h3 id="MVVM-Swift例子——构建一个登录页面"><a href="#MVVM-Swift例子——构建一个登录页面" class="headerlink" title="MVVM Swift例子——构建一个登录页面"></a>MVVM Swift例子——构建一个登录页面</h3><p>在这篇文章中，我们将实现一个在View Model中来处理数据的登录功能。对于这个比较，我将忽略自动布局的部分和xib的变化，集中在VC和VM的联系上。现在，让我们开始吧。</p>
<p><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.29.18-PM.png" alt></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> emailTextField: <span class="type">UITextField!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> passwordTextField: <span class="type">UITextField!</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> loginButton: <span class="type">UIButton!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">didTapOnLoginButton</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是在这个启动项目中我所得到的一切。我们有所有的IBOutlet和IBAction——当然，还有两个重要的文件（VM，VC）。</p>
<p>我们将在这里讨论每个文件。如我们在文章开头所见，我们都知道VC的角色是只做展示和从UI获取信息。我们将在此处应用这些点：</p>
<ul>
<li>从UI获取信息：输入框的输入信息</li>
<li>展示和响应来自VM的数据：点击登录按钮之后，我们将看见一条表示用户是否登录成功的消息。这取决于来自VM的信号</li>
</ul>
<p>好了，问题就是我们如何将这两个文件彼此联系起来。有两种常用方法：protocol-delegate和RxSwift。在这一部分，我将谈谈protocol-delegate。这种方法有两个优点：</p>
<ul>
<li>非常清楚明确，我们可以知道两个类之间传递的基本信息</li>
<li>负责任何特定部分的组件将彼此完全独立</li>
</ul>
<h4 id="1-从View-Controller发送消息到View-Model"><a href="#1-从View-Controller发送消息到View-Model" class="headerlink" title="1. 从View Controller发送消息到View Model"></a>1. 从View Controller发送消息到View Model</h4><p>这一部分里，有三个步骤：</p>
<h5 id="步骤1-创建一个ViewModelDelagte的协议"><a href="#步骤1-创建一个ViewModelDelagte的协议" class="headerlink" title="步骤1: 创建一个ViewModelDelagte的协议"></a>步骤1: 创建一个ViewModelDelagte的协议</h5><p>这个协议是View Model的一部分，它有一个函数叫做：<br><code>func sendValue(from emailTextField: String?, passwordTextField: String?)</code></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewModelDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sendValue</span><span class="params">(from emailTextField: String?, passwordTextField: String?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="步骤2-将View-Model连接到视图层"><a href="#步骤2-将View-Model连接到视图层" class="headerlink" title="步骤2: 将View Model连接到视图层"></a>步骤2: 将View Model连接到视图层</h5><p>接着，我们将在view controller中创建一个 viewModel 变量，从这里发送emailTextField和passwordTextField的值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewModel = <span class="type">ViewModel</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">didTapOnLoginButton</span><span class="params">(<span class="number">_</span> sender: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">    viewModel.sendValue(from: emailTextField.text, passwordTextField: passwordTextField.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好了，看起来挺酷，对吧？看起来我们已经将信息打包封装并发送出去了，接下来我们将看到在哪里去接收并解包这个信息。</p>
<h5 id="步骤3-在View-Model中处理Actions"><a href="#步骤3-在View-Model中处理Actions" class="headerlink" title="步骤3: 在View Model中处理Actions"></a>步骤3: 在View Model中处理Actions</h5><p>在从view controller得到信息之后，我们可以在View Model像这样处理：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendValue</span><span class="params">(from emailTextField: String?, passwordTextField: String?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> emailTextField = emailTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> passwordTextField = passwordTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"emailTextField: \(emailTextField)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"passwordTextField: \(passwordTextField)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行并填充一些数据， 看看会发生什么。<br><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.37.43-PM.png" alt></p>
<p>可以看到，我接收到了来自VC的“Email Testing”和“Password Testing”。</p>
<h4 id="2-从view-model发送数据返回到视图层"><a href="#2-从view-model发送数据返回到视图层" class="headerlink" title="2. 从view model发送数据返回到视图层"></a>2. 从view model发送数据返回到视图层</h4><p>让我们先创建另一个叫做<code>ViewControllerDelegate</code>的协议，并让view controller遵循这个协议。这意味着我们不关心view model做了什么，我们只是需要操作的结果。</p>
<p>这是MVVM巨大的优点。负责VC的不会在乎VM所做的事情，他们只需要结果。同样地，VM不需要知道VC从哪里或如何从UI获取到值，它只关心需要对这些值做什么。因此，所有的关注点都是分离的，从而使所有组件彼此独立。</p>
<p>在我的例子中，你可以看到编写view model的人将关注的是需要对emailTextField和passwordTextField做的事情，但是不需要知道这些值是从何而来。这个业务逻辑归属于视图层。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getInformationBack</span><span class="params">(handledString: String?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码是前文所提到过的，它有一个方法名为<code>getInformationBack</code>。这意味着我们将通过此方法获取到VM所返回的值。</p>
<p>在ViewModel中，让我们添加一个weak类型的delegate变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">ViewControllerDelegate?</span></span><br></pre></td></tr></table></figure></p>
<p>并将从emailTextField和passwordTextField取回的值发送出去。在此篇教程中，我不会处理任何过于复杂的事情，仅仅只是将两个字符串合并为一，如下所示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendValue</span><span class="params">(from emailTextField: String?, passwordTextField: String?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> emailTextField = emailTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> passwordTextField = passwordTextField <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"emailTextField: \(emailTextField)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"passwordTextField: \(passwordTextField)"</span>)</span><br><span class="line">    delegate?.getInformationBack(handledString: emailTextField + passwordTextField)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>好的，到此，我们在处理了值（实际上我们仅仅合并了而已，但是在一个实际的项目中，你可能会做更多的事情比如验证邮箱、密码并告诉VC它们是否可用）之后封装了最后的输出。现在让我们看看如何将数据返回到view controller。</p>
<p>在VC的<code>viewDidLoad</code>里，添加一行代码：<code>viewModel.delegate = self</code>。还记得我们在VM里有一个delegate变量对吧？这行代码是VC告诉VM它将执行此委托。</p>
<p>然后，我们只需要实现协议并从VM取回数据。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">ViewControllerDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getInformationBack</span><span class="params">(handledString: String?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> handledString = handledString <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The string get from VM: \(handledString)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次编译并运行Xcode项目。现在我们将拥有所需要的一切。我们可以将数据从VC发送到VM，反之亦然。</p>
<p><img src="https://www.iosapptemplates.com/wp-content/uploads/2019/03/Screen-Shot-2019-03-17-at-8.52.33-PM.png" alt></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>让我们总结一下我们所做的。在MVVM里，我们将与计算，处理数据等相关的任务分配给了VM。我们仅允许视图层执行UI琐事并从UI和用户交互中获取值。这样，每个设计组件仅负责一个专门的关注点，并且它们彼此完全独立。就这样。我希望在本文之后，您将对MVVM Swift以及如何使用protocol-delegate设计模式进行实现有一个概观。</p>
<p>MVVM是一个强力的Swift架构模式，它使程序员可以分离其设计组件的关注点，因此，对于任何出色的iOS工程师来说，掌握它都是至关重要的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/在Swift中实现MVVM/" data-id="ckls1u0sm000of0xrfmfpdb2b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVVM/">MVVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SwiftUI中的Property-Wrapper-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/12/SwiftUI中的Property-Wrapper-01/" class="article-date">
  <time datetime="2020-02-12T02:34:36.000Z" itemprop="datePublished">2020-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/12/SwiftUI中的Property-Wrapper-01/">SwiftUI中的Property Wrapper #01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在学习 <code>SwiftUI</code> 的过程中，出现了许多在 <code>Swift</code> 中未曾遇到过的类似 <code>@xxx</code> 的东西，在 <code>SwiftUI</code> 中被称作 <code>Property Wrapper</code>。今天就来学习一下 <code>Property Wrapper</code> 应该怎么使用以及应该什么时候使用。</p>
<p><code>SwiftUI</code> 中常见的 <code>Property Wrapper</code> 有 <code>@State</code>，<code>@Binding</code>，<code>@ObservedObject</code>，<code>@EnvironmentObject</code> 以及 <code>@Environment</code>等等。接下来就开始分别学习。</p>
<h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p><code>@State</code> 用来描述视图的状态，它所修饰的变量被存储在视图结构之外一个特殊的内部内存空间，只有相关联的视图能够访问。一旦 <code>@State</code> 所修饰的变量发生改变，<code>SwiftUI</code> 将根据所发生的改变重建试图。下面是一个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProductsView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> products: [<span class="type">Product</span>]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showFavorited: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123; <span class="keyword">self</span>.showFavorited.toggle() &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(<span class="string">"Change filter"</span>)&#125;</span><br><span class="line">            )</span><br><span class="line">            </span><br><span class="line">            <span class="type">ForEach</span>(products) &#123; product <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> !<span class="keyword">self</span>.showFavorited || product.isFavorited &#123;</span><br><span class="line">                    <span class="type">Text</span>(product.title)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，一旦按下按钮，<code>@State</code> 所修饰的<code>showFavorited</code> 的值就发生改变，整个视图也将被重新创建。</p>
<h3 id="Binding"><a href="#Binding" class="headerlink" title="@Binding"></a>@Binding</h3><p><code>@Binding</code> 为值类型提供了引用访问的方式。有时我们需要使子视图能够访问父视图的状态，但是不能够简单地把值传递过去，因为状态是值类型，SwiftUI 只会传递这个值的一个拷贝。这时候 @Binding 就派上用场了：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FilterView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Binding</span> <span class="keyword">var</span> showFavorited: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Toggle</span>(isOn: $showFavorited) &#123;</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Change filter"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProductsView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> products: [<span class="type">Product</span>]</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showFavorited: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">FilterView</span>(showFavorited: $showFavorited)</span><br><span class="line">            </span><br><span class="line">            <span class="type">ForEach</span>(products) &#123; product <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> !<span class="keyword">self</span>.showFavorited || product.isFavorited &#123;</span><br><span class="line">                    <span class="type">Text</span>(product.title)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，使用 @Binding 去标记 showFavorited ，这样的话，FilterView 对showFavorited的读写实际就是对ProductsView中的showFavorited进行读写。而根据上一节 @State 所讲到的内容，ProductsView 的 showFavorited 一改变，SwiftUI 就将重新创建此视图。</p>
<blockquote>
<p>@Binding只适合对值类型的变量进行修饰，如果对非值类型的变量进行修饰可能会引起未知的错误。</p>
<p>另外，对 @Binding 修饰的变量传值的时候一定要加上 <code>$</code> 符号，代表是传递的引用，否则就是传递值的拷贝。</p>
</blockquote>
<h3 id="ObservedObject"><a href="#ObservedObject" class="headerlink" title="@ObservedObject"></a>@ObservedObject</h3><p>@ObservedObject 是 Combine 框架中的一部分，主要用于处理 SwiftUI 之外的一些事物——比如业务逻辑。可以在不同的独立的视图之间共享、观察和订阅 @ObservedObject 所修饰的变量。一旦变量发生改变，所有绑定此变量的视图都将重建。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Combine</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PodcastPlayer</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">play</span><span class="params">()</span></span> &#123;</span><br><span class="line">        isPlaying = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        isPlaying = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PodcastPlayer</code> 可以在多个视图之间共享，在 <code>@Published</code> 属性的帮助下，<code>SwiftUI</code> 可以追踪 <code>@ObservableObject</code> 的变化。一旦 <code>@Published</code> 发生变化，所有绑定 <code>@ObservableObject</code> 的视图都将被重建。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EpisodesView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> player: <span class="type">PodcastPlayer</span></span><br><span class="line">    <span class="keyword">let</span> episodes: [<span class="type">Episode</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(</span><br><span class="line">                action: &#123;</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.player.isPlaying &#123;</span><br><span class="line">                        <span class="keyword">self</span>.player.pause()</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">self</span>.player.play()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                label: &#123; <span class="type">Text</span>(player.isPlaying ? <span class="string">"Pause"</span>: <span class="string">"Play"</span>) &#125;</span><br><span class="line">            )</span><br><span class="line">            <span class="type">ForEach</span>(episodes) &#123; episode <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(episode.title)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为可以在多个视图之间共享数据，因此 ObservableObject 必须是引用类型。</p>
</blockquote>
<h3 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h3><p>@EnvironmentObject 可以将变量隐式地注入到试图层级的环境中。举例说明：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> player = <span class="type">PodcastPlayer</span>()</span><br><span class="line">window.rootViewController = <span class="type">UIHostingController</span>(</span><br><span class="line">    rootView: <span class="type">EpisodesView</span>(episode: episodes)</span><br><span class="line">        .environmentObject(player)</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EpisodeView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">@<span class="type">EnvironmentObject</span> <span class="keyword">var</span> player: <span class="type">PodcastPlayer</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上可见，我们可以通过 <code>environmentObject</code> 修饰符来传递 <code>PodcastPlayer</code>，而且可以通过 <code>@EnvironmentObject</code> 轻松地访问。<code>@EnvironmentObject</code> 通过动态成员查找（dynamic member lookup）特性去找到 <code>Environment</code> 中的 <code>PodcastPlayer</code> 实例。这就是为什么不需要在 <code>EpisodesView</code> 初始化的时候传递 <code>PodcastPlayer</code> 实例的原因。</p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="@Environment"></a>@Environment</h3><p>前一章节讨论的是将自定义对象传递到 <code>Environment</code> 中，但是 <code>SwiftUI</code> 已经存在许多系统级的设置，通过 <code>@Environment</code> 可以轻松地进行访问。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CalendarView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">Environment</span>(\.calendar) <span class="keyword">var</span> calendar: <span class="type">Calendar</span></span><br><span class="line">    @<span class="type">Environment</span>(|.locale) <span class="keyword">var</span> locale: <span class="type">Locale</span></span><br><span class="line">    @<span class="type">Environment</span>(\/colorScheme) <span class="keyword">var</span> colorScheme: <span class="type">ColorScheme</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Text</span>(locale.identifier)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>@Environment</code> 实现了访问和订阅系统级设置的变化。这些系统设置变化，<code>App</code> 中对应的视图也将被重建。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/12/SwiftUI中的Property-Wrapper-01/" data-id="ckls1u0qo0000f0xr31pyj98v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS二维码的识别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/16/iOS二维码的识别/" class="article-date">
  <time datetime="2017-09-16T02:10:21.000Z" itemprop="datePublished">2017-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/16/iOS二维码的识别/">iOS中二维码的识别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><blockquote>
<p><strong>二维条码</strong>是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，而其长度没有记载数据。二维条码的长度、宽度均记载着数据。</p>
<p>二维条码在商业活动中应用广泛，特别是在高科技行业、储存运输业、批发零售业等需要对物品进行廉价快捷的标示信息的行业用途广泛。</p>
</blockquote>
<p>闲话少叙，二维码的应用已经到了无孔不入的地步，只要是个规模稍大点儿的APP就基本支持二维码的识别，所以，本文就讲讲二维码的识别。</p>
        
          <p class="article-more-link">
            <a href="/2017/09/16/iOS二维码的识别/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/16/iOS二维码的识别/" data-id="ckls1u0r50003f0xrmsyh6kw5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二维码/">二维码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中绘制SVG（二）：path命令的绘制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/26/iOS中绘制SVG（二）：path命令的绘制/" class="article-date">
  <time datetime="2017-08-26T04:59:28.000Z" itemprop="datePublished">2017-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/26/iOS中绘制SVG（二）：path命令的绘制/">iOS中绘制SVG（二）：path命令的绘制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Path 命令的绘制分为两个部分，第一步是解析 path 的命令和参数，第二部是根据解析出的数据生成正确的贝塞尔曲线然后进行绘制。</p>
<p>Path 命令一共有 10 个子命令，并且区分大小写，大写代表绝对定位，小写代表相对定位，为了方便描述，在下文所有命令都以大写表示，只在代码中进行大小写——即相对定位和绝对定位的区分。</p>
<ul>
<li>M：移动命令，即 move；</li>
<li>L：线段命令，即 line；</li>
<li>H：根据上一条 path 的终点添加一条水平方向的线段；</li>
<li>V：根据上一条 path 的终点添加一条垂直方向的线段；</li>
<li>A：添加一段弧线；</li>
<li>C：添加一段 curve，即二次贝塞尔曲线；</li>
<li>Q：添加一段 quad curve，即三次贝塞尔曲线；</li>
<li>S：在 C 命令后追加一段镜像 curve；</li>
<li>T：在 Q 命令后追加一段镜像 quad curve；</li>
<li>Z：close 当前的path。</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2017/08/26/iOS中绘制SVG（二）：path命令的绘制/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/26/iOS中绘制SVG（二）：path命令的绘制/" data-id="ckls1u0si000mf0xrh92oxuxu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG/">SVG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中绘制SVG（一）：SVG文件的解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/24/iOS中绘制SVG（一）：SVG文件的解析/" class="article-date">
  <time datetime="2017-08-24T10:58:16.000Z" itemprop="datePublished">2017-08-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/24/iOS中绘制SVG（一）：SVG文件的解析/">iOS中绘制SVG（一）：SVG文件的解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="0x01-SVG-的实质"><a href="#0x01-SVG-的实质" class="headerlink" title="0x01 SVG 的实质"></a>0x01 SVG 的实质</h3><p>SVG实质上是一个XML格式的文本文件，可以同普通的XML文件一样通过一些XML解析库来进行解析。因此绘制SVG的过程实际上是先解析XML文件，然后根据解析出来的命令在屏幕上绘制出来。</p>
<p>SVG的命令常见的有形状、transform、文字、渐变和滤镜。在本系列的文章中，只讨论基本的形状绘制，不涉及文字、渐变和滤镜的部分。</p>
        
          <p class="article-more-link">
            <a href="/2017/08/24/iOS中绘制SVG（一）：SVG文件的解析/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/08/24/iOS中绘制SVG（一）：SVG文件的解析/" data-id="ckls1u0qz0002f0xrk36dayes" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SVG/">SVG</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-在Swift中实现深拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/24/在Swift中实现深拷贝/" class="article-date">
  <time datetime="2017-05-24T03:02:44.000Z" itemprop="datePublished">2017-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/24/在Swift中实现深拷贝/">在Swift中实现深拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="关于数组拷贝的例子"><a href="#关于数组拷贝的例子" class="headerlink" title="关于数组拷贝的例子"></a>关于数组拷贝的例子</h3><p>首先，先看一个例子。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teachers = [<span class="type">Teacher</span>(name: <span class="string">"Alex"</span>, age: <span class="number">32</span>)]</span><br><span class="line"><span class="keyword">var</span> students = [<span class="type">Student</span>(name: <span class="string">"Bob"</span>, age: <span class="number">18</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> teachersCopy = teachers</span><br><span class="line"><span class="keyword">var</span> studentsCopy = students</span><br><span class="line"></span><br><span class="line">teachersCopy[<span class="number">0</span>].name = <span class="string">"AlexCopy"</span></span><br><span class="line">studentsCopy[<span class="number">0</span>].name = <span class="string">"BobCopy"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(teachers[<span class="number">0</span>].name, teachersCopy[<span class="number">0</span>].name) <span class="comment">// "Alex AlexCopy"</span></span><br><span class="line"><span class="built_in">print</span>(students[<span class="number">0</span>].name, studentsCopy[<span class="number">0</span>].name) <span class="comment">// "BobCopy BobCopy"</span></span><br></pre></td></tr></table></figure>
<p>为什么会出现上述这种情况呢？根据 Apple 的文档来看：</p>
<blockquote>
<p>Each array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array.</p>
</blockquote>
<p>简单翻译一下的意思就是，每个数组包括它包含的所有元素都有其独立的值。对于简单类型例如整型和其它结构来说，这意味着当你改变一个数组中的值时，该元素的值在数组的其它副本中的值并不会随之改变。</p>
<blockquote>
<p>If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays. </p>
</blockquote>
<p>但是，如果数组中的元素是类的实例的话，在这种情况下，数组中存储的只是存在于数组外部的对象的引用。如果在一个数组中更改对对象的引用，则只有该数组具有对新对象的引用。 但是，如果两个数组包含对同一对象的引用，则可以从两个数组中观察到对该对象属性的更改。</p>
<p>回到我们的例子，因为 <code>Teacher</code>是一个结构体，属于简单数据类型，当存放它的数组被 copy 的时候，同时复制了数组中所有元素的值。所以，更改<code>teachersCopy</code>中的元素的时候原数组不受影响。</p>
<p>而<code>Student</code>是一个<code>class</code>，当存放<code>Student</code>的数组被复制的时候，复制的其实是对象的引用，因此对<code>studentsCopy</code>中的元素更改值的时候，两个数组中的元素都被更改。</p>
<h3 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h3><p>那么如何实现包含类实例的深拷贝呢？众所周知，在<code>Objective-C</code>中自定义类要实现copy需要遵循<code>NSCopying</code>协议。在 Swift 中也是一样的做法。</p>
<p>首先，定义一个<code>Coping</code>协议。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Copying</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">(original: <span class="keyword">Self</span>)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Copying</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">()</span></span> -&gt; <span class="type">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Self</span>.<span class="keyword">init</span>(original: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，让我们的自定义类遵循这个协议，并实现相应的方法。同时，在 copy 数组的时候也要改变方式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Copying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(original: <span class="type">Student</span>) &#123;</span><br><span class="line">        name = original.name</span><br><span class="line">        age = original.age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> studentsCopy = [<span class="type">Student</span>]()</span><br><span class="line"><span class="keyword">for</span> student <span class="keyword">in</span> students &#123;</span><br><span class="line">    <span class="keyword">let</span> copiedStudent = student.copy()</span><br><span class="line">    studentsCopy.append(copiedStudent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，再修改<code>studentsCopy</code>中的内容，<code>students</code>就不会再随之改变了，数组的深拷贝也就实现了。</p>
<p>当然，还有更精简一些的写法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Copying</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">()</span></span> -&gt; <span class="type">Array</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> copiedArray = <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;()</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            copiedArray.append(element.copy)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copiedArray</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> studentsCopy = students.copy()</span><br></pre></td></tr></table></figure>
<p>That’s done.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/24/在Swift中实现深拷贝/" data-id="ckls1u0re0006f0xrtlt8u30t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/">MVVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Objective-C/">Objective-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SVG/">SVG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二维码/">二维码</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/Objective-C/" style="font-size: 10px;">Objective-C</a> <a href="/tags/SVG/" style="font-size: 15px;">SVG</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/二维码/" style="font-size: 10px;">二维码</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/13/在Swift中实现MVVM/">【翻译】在Swift中实现MVVM</a>
          </li>
        
          <li>
            <a href="/2020/02/12/SwiftUI中的Property-Wrapper-01/">SwiftUI中的Property Wrapper #01</a>
          </li>
        
          <li>
            <a href="/2017/09/16/iOS二维码的识别/">iOS中二维码的识别</a>
          </li>
        
          <li>
            <a href="/2017/08/26/iOS中绘制SVG（二）：path命令的绘制/">iOS中绘制SVG（二）：path命令的绘制</a>
          </li>
        
          <li>
            <a href="/2017/08/24/iOS中绘制SVG（一）：SVG文件的解析/">iOS中绘制SVG（一）：SVG文件的解析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Alexius<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>